import fs from 'fs'
import Path from 'path'
import hkdf from 'futoin-hkdf'
import git from 'isomorphic-git'
import http from 'isomorphic-git/http/web'
import { EncryptedFS } from 'encryptedfs'

const vfs = require('virtualfs')

export default class Vault {

  private key: Buffer
  private keyLen: number
  name: string
  efs: EncryptedFS
  private secrets: Map<string, any>
  private vaultPath: string
  constructor(
    name: string,
    symKey: Buffer,
    baseDir: string
  ) {
    // how do we create pub/priv key pair?
    // do we use the same gpg pub/priv keypair
    this.keyLen = 32
    this.key = this.genSymKey(symKey, this.keyLen)
    // Set filesystem
    const vfsInstance = new vfs.VirtualFS

    this.efs = new EncryptedFS(
      symKey,
      vfsInstance,
      vfsInstance,
      fs,
      process
    )

    this.name = name
    this.vaultPath = Path.join(baseDir, name)
    // make the vault directory
    this.efs.mkdirSync(this.vaultPath, {recursive: true})
    this.secrets = new Map()

    this.loadSecrets()
  }

  loadSecrets() {
    const secrets = fs.readdirSync(this.vaultPath, undefined)

    for (const secret of secrets) {
      this.secrets.set(secret, null)
    }
  }

  genSymKey(asymKey: Buffer, keyLen: number): Buffer {
    return Buffer.from(hkdf(asymKey.toString(), keyLen))
  }

  secretExists(secretName: string) : boolean {
    const secretPath = Path.join(this.vaultPath, secretName)
    return this.secrets.has(secretName) && this.efs.existsSync(secretPath)
  }

  async addSecret(secretName: string, secretBuf: Buffer): Promise<void> {
    // Check if secret already exists
    if (this.secrets.has(secretName)) {
      throw new Error('Secret already exists, try updating it instead.')
    }
    const writePath = Path.join(this.vaultPath, secretName)
    // Write secret
    await this.efs.writeFile(writePath, secretBuf)
    // Update secrets map
    this.secrets.set(secretName, secretBuf)
    // Auto commit message
    await this.commitChanges(`Add secret: ${secretName}`, secretName)
  }

  async updateSecret(secretName: string, secretBuf: Buffer): Promise<void> {
    // Check if secret already exists
    if (!this.secrets.has(secretName)) {
      throw new Error('Secret does not exist, try adding it instead.')
    }
    const writePath = Path.join(this.vaultPath, secretName)
    // Write secret
    await this.efs.writeFile(writePath, secretBuf)
    // Update secrets map
    this.secrets.set(secretName, secretBuf)
    // Auto commit message
    await this.commitChanges(`Update secret: ${secretName}`, secretName)
  }

  getSecret(secretName: string): Buffer | string {
    if (this.secrets.has(secretName)) {
      const secret = this.secrets.get(secretName)
      if (secret) {
        return secret
      } else {
        const secretPath = Path.join(this.vaultPath, secretName)
        // TODO: this should be async
        const secretBuf = this.efs.readFileSync(secretPath, {})
        this.secrets.set(secretName, secretBuf)
        return secretBuf
      }
    }
    throw Error('Secret: ' + secretName + ' does not exist')
  }

  async removeSecret(secretName: string): Promise<void> {
    if (this.secrets.has(secretName)) {
      const successful = this.secrets.delete(secretName)
      // Auto commit message
      await this.commitChanges(`Remove secret: ${secretName}`, secretName)
      if (successful) {
        return
      }
      throw Error('Secret: ' + secretName + ' was not removed')
    }
    throw Error('Secret: ' + secretName + ' does not exist')
  }

  listSecrets(): string[] {
    let secrets: string[] = Array.from(this.secrets.keys())
    return secrets
  }

  tagVault(tag: string) { // websites

  }

  untagVault() {

  }

  shareVault() {
  }

  unshareVault() {
  }

  // ============== Helper methods ============== //

  async initRepository() {
    const fileSystem = { promises: this.efs }
    await git.init({
      fs: fileSystem,
      dir: this.vaultPath
    })

    // Write packed-refs file because isomorphic git goes searching for it
    // and apparently its not autogenerated
    this.efs.writeFileSync(Path.join(this.vaultPath, '.git', 'packed-refs'), '# pack-refs with: peeled fully-peeled sorted')
  }

  private async commitChanges(message: string, secretName: string): Promise<string> {
    await git.add({
      fs: { promises: this.efs },
      dir: this.vaultPath,
      filepath: secretName
    })
    return await git.commit({
      fs: { promises: this.efs },
      dir: this.vaultPath,
      author: {
        name: this.name
      },
      message: message
    })
  }

  async pullVault(address: string) {
    await git.pull({
      fs: this.efs,
      http: http,
      dir: this.vaultPath,
      url: address,
      ref: 'master',
      singleBranch: true
    })
  }
}
